<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on stanley的博客</title>
    <link>https://stanleylfc.github.io/post/</link>
    <description>Recent content in Posts on stanley的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2020 21:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://stanleylfc.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>go 实战（十三）| go probuf</title>
      <link>https://stanleylfc.github.io/post/golang/2020-05-05-golang-probuf/</link>
      <pubDate>Tue, 05 May 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-05-05-golang-probuf/</guid>
      <description></description>
    </item>
    
    <item>
      <title>go 包练习（一）| go viper cron cobra</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-30-goalng-%E5%8C%8501/</link>
      <pubDate>Tue, 28 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-30-goalng-%E5%8C%8501/</guid>
      <description>1.读取配置文件viper 2.定时任务cron github.com/gogits/cron 3.子命令cobra</description>
    </item>
    
    <item>
      <title>go 实战（十二）| go grpc开发</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-28-golang-gpc/</link>
      <pubDate>Tue, 28 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-28-golang-gpc/</guid>
      <description>1. RPC 远程调用 https://github.com/grpc/grpc-go go get -u google.golang.org/grpc 2. Protobuf Google Protocol Buffer 2.1 安装 protobuf 下载对应版本解压后配置环境变量 https://github.com/protocolbuffers/protobuf/releases 2.2 protocol 格式教程 https://developers.google.com/protocol-buffers/docs/gotutorial 3. 中间文件 3.1 安装插件 在GOPATH的bin目录下生产可执行文件.protobuf的编译器插件protoc-gen-go go get github.com/golang/protobuf/protoc-gen-go 3.2书写中间文件 syntax=&amp;quot;proto3&amp;quot; package services message ProdRequest { int32 prod_id=1 } message ProdResponse { int32 prod_stock=1 } 3.3 编译安装 在pbfil</description>
    </item>
    
    <item>
      <title>go 实战（十一）| go web开发</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-27-golang-web%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 27 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-27-golang-web%E5%BC%80%E5%8F%91/</guid>
      <description>1.web服务器 1.1 创建web服务器 只要调用ListenAndServe 并传入网络地址以及负责处理请求的处理器（handler）作为参数就可以了 // http.ListenAndServe(&amp;quot;&amp;quot;, nil) 1.2 带有附加配置的Web服务器 server := http.Server{ Addr: &amp;quot;127.0.0.1:8080&amp;quot;, Handler: nil, } server.ListenAndServe() 2.处理器 一个处理器就是一个拥有ServeHTTP 方法的接口。 任何接口只要拥有一个Se</description>
    </item>
    
    <item>
      <title>vue 实战（一）| vue</title>
      <link>https://stanleylfc.github.io/post/vue/2020-04-23-vue-vue/</link>
      <pubDate>Thu, 23 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/vue/2020-04-23-vue-vue/</guid>
      <description>VUEX中的dispatch()和commit() commit: 同步操作 存储 this.$store.commit(&#39;changeValue&#39;,name) 取值 this.$store.state.changeValue dispatch: 异步操作 存储 this.$store.dispatch(&#39;getlists&#39;,name) 取值 this.$store.getters.getlists this.$store.dispatch(&#39;user/login&#39;, this.loginForm) 访问store 下面user 模块的login 方法 router.push(&#39;/login&#39;) &#39;/login&#39;前端路由</description>
    </item>
    
    <item>
      <title>vue 实战（三）| vuecli</title>
      <link>https://stanleylfc.github.io/post/vue/2020-04-23-vue-vuecli/</link>
      <pubDate>Thu, 23 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/vue/2020-04-23-vue-vuecli/</guid>
      <description>1. 安装 1.1 安装vue-cli npm install -g @vue/cli # -g 全局安装 1.2 版本查看 这个命令来检查其版本是否正确 vue --version 2. 创建项目 2.1 创建项目命令 vue create testapp 2.2 选择自定义 default (babel, eslint) ❯ Manually select features 2.3 空格选择，enter确认 ❯◉ Babel ◯ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router ◯ Vuex ◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 2.4 配置独立一个文件还是一个文件 In dedicated config files &amp;gt; In package.json 2.5 tree -L 1 查</description>
    </item>
    
    <item>
      <title>vue 实战（二）| node</title>
      <link>https://stanleylfc.github.io/post/vue/2020-04-22-vue-node/</link>
      <pubDate>Wed, 22 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/vue/2020-04-22-vue-node/</guid>
      <description></description>
    </item>
    
    <item>
      <title>git 实战（二）| git 提交分支</title>
      <link>https://stanleylfc.github.io/post/git/2020-04-22-git-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/git/2020-04-22-git-%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</guid>
      <description>1. Commit message 的格式 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 格式如下： &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;):&amp;lt;subject&amp;gt; // 空一行 &amp;lt;body&amp;gt; // 空一行 &amp;lt;footer&amp;gt; 1.1 Header Head</description>
    </item>
    
    <item>
      <title>go 实战（七）| 内存详解</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-16-golang-%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-16-golang-%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>go 实战（九）| goroutine原理</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-16-golang-goroutine%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-16-golang-goroutine%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>go 实战（五）| go 编译和启动</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-14-golang-%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-14-golang-%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</guid>
      <description>1. 启动脚本 1.1 编译好的二进制 #!/bin/bash SERVER=&amp;quot;apiserver&amp;quot; BASE_DIR=$PWD INTERVAL=2 # 命令行参数，需要手动指定 ARGS=&amp;quot;&amp;quot; function start() { if [ &amp;quot;`pgrep $SERVER -u $UID`&amp;quot; != &amp;quot;&amp;quot; ];then echo &amp;quot;$SERVER already running&amp;quot; exit 1 fi nohup $BASE_DIR/$SERVER $ARGS server &amp;amp;&amp;gt;/dev/null &amp;amp; echo &amp;quot;sleeping...&amp;quot; &amp;amp;&amp;amp; sleep $INTERVAL # check status if [ &amp;quot;`pgrep $SERVER -u $UID`&amp;quot; == &amp;quot;&amp;quot; ];then echo &amp;quot;$SERVER start failed&amp;quot; exit 1 fi } function status() { if [ &amp;quot;`pgrep $SERVER -u $UID`&amp;quot; != &amp;quot;&amp;quot; ];then echo $SERVER is running else echo $SERVER is not running fi } function stop() { if [ &amp;quot;`pgrep $SERVER -u $UID`&amp;quot; != &amp;quot;&amp;quot; ];then kill -9 `pgrep $SERVER -u $UID` fi echo &amp;quot;sleeping...&amp;quot; &amp;amp;&amp;amp; sleep $INTERVAL if [ &amp;quot;`pgrep $SERVER -u $UID`&amp;quot; != &amp;quot;&amp;quot; ];then echo &amp;quot;$SERVER</description>
    </item>
    
    <item>
      <title>go 实战（八）| GC 垃圾回收</title>
      <link>https://stanleylfc.github.io/post/golang/2020-04-15-golang-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/golang/2020-04-15-golang-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>Go GC 垃圾回收 垃圾回收机制 引用计数 标志清楚 三色标志 分代收集 GO GC 发展 1.1 1.2 三色标记 2.1 写屏障 2.2 三色状态 GC 执行流程 3.1 启动 3.2 标记 3.3 清理</description>
    </item>
    
    <item>
      <title>hadoop 实战（一）| hadoop 安装</title>
      <link>https://stanleylfc.github.io/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/2020-04-27-hadoop2.7.7%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/2020-04-27-hadoop2.7.7%E5%AE%89%E8%A3%85/</guid>
      <description>1.环境准备 1.1 服务器规划 # -u root -p centosdata 172.16.232.130 centos701 172.16.232.131 centos702 172.16.232.132 centos703 1.2 关闭所有服务器的防火墙 systemctl stop firewalld.service # 停止firewall。 systemctl disable firewalld.service # 禁止firewall开机启动。 firewall-cmd --state # 查看默认防火墙装状态(关闭后显示notrunning, 开启显示running)。 1.3 关闭服务器的SLNEX vim /etc/selinux/config SELINUX=disabled 1.4 服务器ssh 安装 所有服务</description>
    </item>
    
    <item>
      <title>hadoop 实战（一）| hadoop 安装</title>
      <link>https://stanleylfc.github.io/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/2020-04-27-live2.7.7%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 21 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/2020-04-27-live2.7.7%E5%AE%89%E8%A3%85/</guid>
      <description>1.环境准备 1.1 服务器规划 # -u root -p centosdata 172.16.232.130 centos701 172.16.232.131 centos702 172.16.232.132 centos703 1.2 关闭所有服务器的防火墙 systemctl stop firewalld.service # 停止firewall。 systemctl disable firewalld.service # 禁止firewall开机启动。 firewall-cmd --state # 查看默认防火墙装状态(关闭后显示notrunning, 开启显示running)。 1.3 关闭服务器的SLNEX vim /etc/selinux/config SELINUX=disabled 1.4 服务器ssh 安装 所有服务</description>
    </item>
    
    <item>
      <title>vue 实战（六）| Vue Router</title>
      <link>https://stanleylfc.github.io/post/vue/2020-04-22-vue-Vue-Router/</link>
      <pubDate>Sun, 19 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/vue/2020-04-22-vue-Vue-Router/</guid>
      <description>1 html 1.1 router-link 使用 router-link 组件来导航。 通过传入 to 属性指定链接。 默认会被渲染成一个 &amp;lt;a&amp;gt; 标签。 &amp;lt;router-link to=&amp;quot;/foo&amp;quot;&amp;gt;Go to Foo&amp;lt;/router-link&amp;gt; 1.2 router-view 路由出口 路由匹配到的组件将渲染在这里 &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; 2 javascript 2.1 初始化 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter) 2.2 定义组件 定义 (路由) 组件。 可以从其他文件 import 进来 const Foo = { template: &#39;&amp;lt;div&amp;gt;foo&amp;lt;/div&amp;gt;&#39; } const Bar = { template: &#39;&amp;lt;div&amp;gt;bar&amp;lt;/div&amp;gt;&#39; } 2.3</description>
    </item>
    
    <item>
      <title>python 实战（五）| 迭代器</title>
      <link>https://stanleylfc.github.io/post/python/2020-04-05-python-base05/</link>
      <pubDate>Tue, 14 Apr 2020 15:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/python/2020-04-05-python-base05/</guid>
      <description>1.迭代器 1.1 迭代是指重复对象中获取数据，直至结束。 1.2 迭代协议 用__iter__方法返回一个实现了__next__方法的迭代对象，__next__抛出StopIteration 异常表示结束 1.3 自定义类型 class Data: def __init__(self, n): self.data = list(range(n)) def __iter__(self): return DataIter(self.data) #每次新建一个 class DataIter: def __init__(self, data): self.data = data self.index = 0 # 无法通过__next</description>
    </item>
    
    <item>
      <title>linux 实战（一）| syslog</title>
      <link>https://stanleylfc.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2020-05-06-linux-syslog/</link>
      <pubDate>Fri, 03 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/2020-05-06-linux-syslog/</guid>
      <description>1. 安装 一般来说centos都自带了rsyslog, 通过源码包来安装 源码包下载地址:http://www.rsyslog.com/downloads/download-v8-stable/ 使用yum sudo yum install rsyslog 2. 开启我们的rsyslog远程服务 2.1 编辑配置文件 sudo vim /etc/rsyslog.conf 并将以下注释打开 # Provides UDP</description>
    </item>
    
    <item>
      <title>python 实战（四）| 基础知识02</title>
      <link>https://stanleylfc.github.io/post/python/2020-04-03-python-base02/</link>
      <pubDate>Fri, 03 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/python/2020-04-03-python-base02/</guid>
      <description>模块 1.简单模块化 把函数、类、常量拆分到不同的文件，把它们放在同一个文件夹 把函数、类、常量拆分到不同的文件，把它们放在不同的文件 sys.path.append(&amp;quot;..&amp;quot;) # 通过这种方式调用上层目录 2.项目模块化 3.神奇的 if name == &amp;lsquo;main&amp;rsquo; import 在导入文件的时候，会自动把所有暴露在外面的代码全都执行一遍。因此，如果你要把一个东西封装成</description>
    </item>
    
    <item>
      <title>vmware 实战（一）| 创建</title>
      <link>https://stanleylfc.github.io/post/vmware/2020-04-03-vmware-create/</link>
      <pubDate>Fri, 03 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/vmware/2020-04-03-vmware-create/</guid>
      <description>网络配置 文件 功能 /etc/hostsname 修改主机名称 /etc/sysconfig/network-scripts/ifcfg-enoN 设置网卡参数文件（网卡位置） /etc/resolv.conf 设置DNS，用于将域名到ip /etc/hosts 计算机ip对应的主机名或者域名 /ect/nsswitch.conf 优先使用DNS解析还是本地设置优先（name server switch configuration） 1.1网络接口文件 #显示网络接口文件 ip addr #编辑接口文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 #重启网卡 service network restart 1.2 ifcfg-ens33 HWADDR=00:0c:29:39:12:c7</description>
    </item>
    
    <item>
      <title>python 实战（四）| 基础知识01</title>
      <link>https://stanleylfc.github.io/post/python/2020-04-02-python-base01/</link>
      <pubDate>Thu, 02 Apr 2020 09:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/python/2020-04-02-python-base01/</guid>
      <description>数据类型 1.1数字（int, float, bool) int 底层实现上， 通过不定长结构体按需分配内存 2.数字还可以有二进制(bin)，八进制(oct)，以及十六进制(hex)表示0b110011, 0o12, 0x64 3.内置函数将整数转换为指定进制字符串，或反向int 还原 bin(100) &amp;lsquo;0b1100100&amp;rsquo; int(&amp;lsquo;0b1100100&amp;rsquo;, 2) 100 4.python3不支持数字和非数字类型</description>
    </item>
    
    <item>
      <title>python 实战（三）| python 用docker安装</title>
      <link>https://stanleylfc.github.io/post/python/2020-04-02-python-docker/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/python/2020-04-02-python-docker/</guid>
      <description>基础环境 - Linux - Python 3.8 - Docker 1. 容器 docker $ docker pull ubuntu $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 4e5021d210f6 13 days ago 64.2MB 创建容器 $ docker create -ti --privileged --name py3 -p 10000:80 -p 10001:8888 -v /mac/py3:/root/py3 -w /root ubuntu bash -l 启动 $ docker start -ai py3 Docker 后台运行的快捷键是：Ctrl P + Ctrl Q 安装 更新源，安装 Python 3.8 $ apt update $ apt install curl $ apt install python3.8 python3.8-distutils 安装 pip 包管理器 $ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py $ python3.8 get-pip.py $ pip3 -V pip 20.0.2 from /usr/local/lib/python3.8/dist-packages/pip (python 3.8) 安装附加工具 $ pip3 install ipython ipdb</description>
    </item>
    
    <item>
      <title>python 实战（二）| virtualenv</title>
      <link>https://stanleylfc.github.io/post/python/2020-04-01-python-venv/</link>
      <pubDate>Wed, 01 Apr 2020 21:00:00 +0800</pubDate>
      
      <guid>https://stanleylfc.github.io/post/python/2020-04-01-python-venv/</guid>
      <description>1.安装virtualenv pip install virtualenv #(python2) pip3 install virtualenv #(python3) 2.创建venv python3 -m venv venv venv就是虚拟环境的文件夹，通常取名venv(用户自定义)。 --no-site-packages表示不添加系统里面python已安装的第三方库 3.启动虚拟环境并安装第三方库 venv\Script\activate #(windows) source venv/bin/activate #(linux/macos) pip install xxx 4.部署到服务器，环境</description>
    </item>
    
    <item>
      <title></title>
      <link>https://stanleylfc.github.io/post/%E5%BE%AE%E7%A7%AF%E5%88%86/%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://stanleylfc.github.io/post/%E5%BE%AE%E7%A7%AF%E5%88%86/%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD%E6%80%A7/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>